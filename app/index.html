<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div class="container">
      <div class="controls">
        <label>expr: <input id="expr" value="sin(x) * x" size="30"/></label>
        <label>start: <input id="start" value="-6.283" size="7"/></label>
        <label>end: <input id="end" value="6.283" size="7"/></label>
        <label>samples: <input id="samples" value="800" size="5"/></label>
        <button id="draw">Draw</button>
      </div>
      <canvas id="c" width="800" height="400"></canvas>
    </div>

    <script type="module" src="/src/main.ts"></script>
    <script type="module">
      import init, { compute_points } from '@vectorviz/abacus';

      async function main() {
        await init();

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        const exprInput = document.getElementById('expr');
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        const samplesInput = document.getElementById('samples');
        const drawBtn = document.getElementById('draw');

        function clear() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawPoints(points) {
          // points is a Float32Array-like (wasm returns a Float32Array)
          // find bounds for mapping
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          for (let i = 0; i < points.length; i += 2) {
            const x = points[i], y = points[i + 1];
            if (!Number.isFinite(y)) continue;
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
          if (minX === Infinity) return; // nothing valid

          // padding
          const pad = 20;
          const w = canvas.width - pad * 2;
          const h = canvas.height - pad * 2;

          // if flat function, expand Y range slightly
          if (minY === maxY) { minY -= 1.0; maxY += 1.0; }

          function mx(x) { return pad + ((x - minX) / (maxX - minX)) * w; }
          function my(y) { return pad + (1 - (y - minY) / (maxY - minY)) * h; }

          ctx.lineWidth = 1.5;
          ctx.beginPath();
          let started = false;
          for (let i = 0; i < points.length; i += 2) {
            const x = points[i], y = points[i + 1];
            if (!Number.isFinite(y)) { started = false; continue; }
            const px = mx(x), py = my(y);
            if (!started) {
              ctx.moveTo(px, py);
              started = true;
            } else {
              ctx.lineTo(px, py);
            }
          }
          ctx.strokeStyle = 'black';
          ctx.stroke();
        }

        async function render() {
          clear();
          const expr = exprInput.value;
          const start = parseFloat(startInput.value);
          const end = parseFloat(endInput.value);
          const samples = parseInt(samplesInput.value, 10);
          try {
            const raw = compute_points(start, end, samples, expr);
            // raw is already a Float32Array-compatible view (wasm-bindgen returns typed array)
            drawPoints(raw);
          } catch (e) {
            console.error('compute failed', e);
          }
        }

        drawBtn.addEventListener('click', render);

        // initial draw
        render();
      }

      main();
    </script>
  </body>
</html>
